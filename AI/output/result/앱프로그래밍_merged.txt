00:00 ~ 00:07 -  으 으
00:13 ~ 00:30 -  안녕하십니까 코틀린을 사용한 스마트 프로그래밍에 대해서 지금부터 강의를 시작하겠습니다. 제일 처음에는요, Kotlin 이라고 하는 언어 개요에 대해서 살펴보도록 하겠습니다.
00:20 ~ 00:40 - kit Kotlin 을 사용한 스마트 앱 프로그래밍 개요 오병우 컴퓨터공학과 국립금오공과대학교 Kumoh National Institute of Teehnology
00:30 ~ 00:38 -  자 이번 강의는요 코틀린을 사용한 스마트 앱 프로그래밍 제목이 그렇게 되구요
00:38 ~ 00:45 -  원래는 컴퓨터공학과 3학년 2학기에 스마트 앱 프로그래밍이라고 하는 과목이 있는데
00:40 ~ 01:00 - 강의 개요 Kotlin을 스마트앱 프로그래밍 컴퓨터공학과 3학년 2학기 선수 과목 Java 프로그래밍 및 C++프로그래밍 데이터베이스 LMS-내 강의실-공개강좌-컴퓨터공학과 (동영상 강좌) (KOCW에 서도 제공) - 객체지향프로그래밍-객체지향프로그래밍응용연계교육 동영상 Visual C# GUI 프로그래밍 동영상 웹 프로그래밍-데이터베이스 연계교육 동영상 안드로이드 심화 프로그래밍 강의 범위 언어 안드로이드 프로그래밍 Department of Computer Engineering 2 institute of Technology
00:45 ~ 00:49 -  여태까지는 그거를 자바를 가지고 프로그래밍을 했었습니다
00:49 ~ 00:54 -  그래서 그거를 지금부터는 코틀린을 가지고
00:54 ~ 01:00 -  사용을 해 가지고 앱을 개발하도록 그렇게 바꿨습니다.
01:00 ~ 01:09 -  장점이 굉장히 많기 때문에 음 여러분들 걱정이 되실 텐데요 아 나는 코틀린이라는 언어를 들어본 적도 없고
01:09 ~ 01:19 -  자바나 뭐 슈퍼필드 잘 못하는데 할 수 있을까 생각하실 수도 있는데요 오히려 그 자바나 c++를 모르더라도 코틀린 만 알면은 잘
01:19 ~ 01:21 -  하실 수 있으니까 굉장히 좋구요.
01:21 ~ 01:30 -  만약에 자바나 C++ 이런거에 또 잘 하신다 그러면은 코드 틀린도 몇 개 하지만 좀 주의하시면 잘 따져
01:30 ~ 01:38 -  이번 강의를 통해 들어보시고요. 제가 여기서 모든 문법을 다 설명한다는 것은 무리가 있을 거고요.
01:38 ~ 01:49 -  강의를 계속 진행을 하면서 16강까지 가면서 거기서 중간중간에 코틀린 문법을 여러분들이 계속 쓰시다 보면 아마 익히게 되실 거라고 생각이 됩니다.
01:49 ~ 01:52 -  선수 과목에는 j�� 프로그래밍하고
01:52 ~ 01:55 -  C++ 프로그래밍이 있을 수 있고요.
01:55 ~ 02:00 -  그 다음에 데이터베이스라고 하는 과목에서
02:00 ~ 02:02 -  서버 구축하는 내용이 나오기 때문에
02:02 ~ 02:05 -  그런 데이터베이스를 들으시면 좋을 것 같은데요
02:05 ~ 02:09 -  잘 모르시겠다 그래도 크게 걱정하실 필요는 없습니다
02:09 ~ 02:15 -  학교 내에 있는 LMS 내 강의실의 공개강좌
02:15 ~ 02:17 -  거기에 보시면 컴퓨터공학과 탭이 있는데요
02:17 ~ 02:24 -  거기서 이런 강의들을 여러분이 보시면 되겠고 제가 그 다음에 만약에 어떤 특정한 강의를 하는데
02:20 ~ 02:40 - I
02:24 ~ 02:27 -  거기서 필요한 내용이 있다라고 하면
02:27 ~ 02:30 -  그때 첫 장에서 어떤 어떤 것을 들을 수 있는지
02:30 ~ 02:35 -  주시면 된다 라고 여기에 있는 몇 장을 들으면 된다 이렇게 알려 드리도록 하겠습니다
02:35 ~ 02:44 -  만약에 그 금호공대 학생이 아니시고 ko cw 에서 들으시는 분들도 마찬가지로 이 강의들이 전부 다 ko cw 에 올려져 있으니까요
02:44 ~ 02:48 -  제목으로 검색해서 보시면 되겠습니다
02:48 ~ 02:51 -  객체지향 프로그래밍 객체지향 프로그래밍 응용 이�체지향 프로그래밍 응용이라고 하는 것은
02:51 ~ 02:54 -  뒤에 응용이 붙었느냐, 붙지 않았느냐 그 차이죠.
02:54 ~ 03:00 -  그래서 객체지향 프로그래밍, 예를 들면 C++를 배운 학생들이 어떻게 하면
03:00 ~ 03:05 -  mfc 라든지 아니면 c 샵 이런 프로그래밍 어떻게 할지
03:05 ~ 03:15 -  GUI 프로그래밍 어떻게 할지 적어 놓은 거구요. 그래서 이걸 먼저 만들었고 그 뒤에 비주얼 c 샵 GUI 프로그래밍 동영상을 제작했습니다.
03:15 ~ 03:20 -  그래서 여기서는 아예 GUI 프로그래밍에 특화되어 있는데요.
03:20 ~ 03:25 -  여기서도 마찬가지로 비주얼 C샷만 다루고 있는 것은 아니고
03:20 ~ 03:40 - 심화
03:25 ~ 03:30 -  다양한 것들을 MFC 같은 것들을 다루고 있으니까요.
03:30 ~ 03:35 -  참조해 보시면 좋을 거라고 생각이 되구요 그 다음에 아까 그 데이터베이스 말씀을 드렸었는데
03:35 ~ 03:42 -  이론 부분은 들어 있지 않구요 전부 다 프로그래밍 쪽만 들어 있는데 웹프로그래밍 데이터베이스 연계 교육 등의 사항이 있으니까요
03:42 ~ 03:49 -  프로그래밍 하는 방법 여기서 보시면 되겠습니다 그 다음에 안드로이드 심화 프로그래밍 이라고 해서 어 이거는
03:49 ~ 03:51 -  자바로 되어 있는 건데요
03:51 ~ 03:57 -  Android에서 조금 지금 강의에서 다루지 못하는 그런 내용들은
03:57 ~ 04:00 -  이 Android 심화 프로그래밍을 보시면 도움이 되실 것 같습니다.
04:00 ~ 04:07 -  이 전에 스마트 프로그래밍이라는 과목이 있었는데요
04:07 ~ 04:14 -  그것은 지금 이 코틀린을 사용한 스마트 프로그래밍을 가지고 대체 되도록 그렇게 할 것입니다
04:14 ~ 04:20 -  만약에 목차를 보시고 여기서 설명하지 않은 것이 있다 코틀린 쪽에서 설명하지 않은 것이 있다 라고 하면은
04:20 ~ 04:23 -  자바를 보시면 도움이 되실 거라고 생각이 되고요.
04:23 ~ 04:27 -  이 강의에서 하려고 하는 것은 코틀린 언어,
04:27 ~ 04:30 -  그 다음에 안드로이드 프로그래밍 이렇게
04:30 ~ 04:35 -  그래서 Kotlin을 사용해서 안드로이드 프로그래밍을 하겠다는 거죠.
04:35 ~ 04:42 -  Kotlin 언어라고 하는 것은 역사는 여러분이 아실 필요는 없고요.
04:40 ~ 05:00 - 공개는 2011년 Android 공식 개발 언어로 2017년 추가됨 2014년 iOS에서는 기존 Objective-C에 Swift 추가 현대 언어 특징 갖춤 간결한 코드 높은 표현력 생산성 향상 Null Pointer Exception (NPE) 방지 익숙하지 않은 ?를 사용한 문법 이론 보다는 실리 Getter/Setter를 사용하지 않고 default visibility 가 public for loop 문법이 다름 3
04:42 ~ 04:53 -  공개는 2011년도에 됐는데 이때보다 안드로이드에서 공식 개발 언어로 선택이 되면서 더 많은 관심을 끌게 됐죠
04:53 ~ 05:00 -  2017년도에 그런 일이 있었구요 그 전에 앞서 가지고 ios 에서는 ios
05:00 ~ 05:01 -  프로그래밍을 하기 위해서는요.
05:00 ~ 05:20 - 높은 표현력
05:02 ~ 05:04 -  기존의 오브젝티브C 언어에다가
05:04 ~ 05:06 -  스위프트 언어를 추가해가지고
05:06 ~ 05:08 -  사람들한테 좀 각광을 받았습니다.
05:08 ~ 05:12 -  아무래도 이런 스위프트라든지 코틀린이라든지
05:12 ~ 05:14 -  이런 것들은 현대 언어의 특징을 갖추고 있어가지고
05:14 ~ 05:18 -  프로그램을 개발하는데 상당히 좀 간결하면서도
05:18 ~ 05:23 -  생산성을 높일 수 있는 장점들이 있습니다.
05:23 ~ 05:26 -  코틀린 언어의 특성을 여기저기 찾다 보시면
05:26 ~ 05:30 -  Null Point Exception을 방지하는 얘기가 나올텐데요.
05:30 ~ 05:38 -  뭔가 처음에 보면은 물음표가 굉장히 많이 달려 있습니다. 그래서 이게 뭐냐 이렇게 생각하실지 아실 수 있는데 조금 보시다 보면 그렇게 어렵지
05:38 ~ 05:46 -  않으니깐요 나중에 보도록 하구요 그 다음에 이 쿨틀린 언어는 어떤 프로그래밍 언어적인 이론 보다는 좀
05:40 ~ 06:00 - 않은?를
05:46 ~ 05:52 -  실리를 챙겼다 라고 보시면 되겠습니다 그래서 객체지향 개념을 정확히 지키려면
05:52 ~ 05:54 -  데이터를 보호를 하고
05:54 ~ 05:56 -  인캡슐레이션 해놓고
05:56 ~ 06:00 -  그 다음에 public으로 getter, setter를 가지고
06:00 ~ 06:06 -  이 Kotlin 언어에서는 default visibility, 접근 지정자가 보인다고 하는데요.
06:06 ~ 06:11 -  default visibility가 public으로 되어 있습니다.
06:11 ~ 06:15 -  아무것도 지정하지 않으면 그냥 public 이라는 거죠.
06:15 ~ 06:20 -  이래서 쉽게 쓸 수 있도록 그렇게 해놨고요.
06:20 ~ 06:25 -  그 다음에 대표적으로 for loop 같은 것이 약간 좀 다릅니다. 우리가 맨날 쓰던
06:25 ~ 06:30 -  for loop가 안되니까 이게 왜 안되지 하시면은
06:30 ~ 06:39 -  그거를 만약에 다른 데다가 타이핑을 하시고 그걸 아마 컨트롤 C 하시고 안드로이드 스튜디오에 붙여넣기 하시면 자동으로
06:39 ~ 06:47 -  for loop를 코틀린 문법으로 바꿔 줄 거라고 생각이 됩니다. 코틀린에서 이름 짓는 규칙 네이밍 컨벤션이죠. 이거 보면은
06:40 ~ 07:00 - Naming Conventions 이름 짓는 규칙 여러 단어일 때 Camel case humps (낙타 혹) 처럼 이어지는 단어의 첫 글자 대문자 ex) mediaPlayer class 및 object (명사): 첫 글자 대문자 derived: base (파생 클래스 한 칸 띄고콜론,띄우고기반클래스) var. val 첫 글자 소문자 변수명: 타입 (변수명 바로 뒤에 콜론, 한 칸 띄고 타입) fun (동사): Factory fun: 글자 대문자 const: 모두 대문자 및_ (under bar) 사용 블록 시작 중괄호는 한줄 내리지 말고 오른쪽에 위치 4
06:47 ~ 07:00 -  일단 처음에는 여러 단어일 때 camel case, 낙타 혹처럼 시작을 하다가 첫 글자를 첫 글자 그러니까 두번째 단어의 첫 글자를 대문
07:00 ~ 07:04 -  이런 camel 케이스를 사용하는데요. 예를 들면 이런거죠.
07:00 ~ 07:20 - 대문자 및 중괄호는 한 줄 내리지 말고
07:04 ~ 07:09 -  미디어 라고 하는 단어하고 플레이어 라고 하는 단어 두 개가 합쳐지다 보니까
07:09 ~ 07:13 -  미디어는 이렇게 쓰고 플레이어에 시작하는 두 번째 단어의
07:13 ~ 07:18 -  첫 글자를 대문자로 쓰는 이런 거라고 보시면 되겠습니다.
07:20 ~ 07:30 -  자 그 다음에 클래스하고 오브젝트라고 하는 것이 있는데요. 이 class하고 object에서는 첫 글자를 대문자로 쓰시면 되겠구요. 그 다음에 참고적으로
07:20 ~ 07:40 - 및 object
07:30 ~ 07:32 -  이렇게 파생 클래스가 있고, 서브 클래스가 있고,
07:32 ~ 07:34 -  슈퍼 클래스가 있다고 했을 때는
07:34 ~ 07:39 -  여기에 이 콜론 앞뒤로 한 칸씩 이렇게 띄워 주셔야 됩니다
07:39 ~ 07:41 -  뭐 꼭 그렇게 안 해도 되긴 하지만
07:40 ~ 08:00 - derived Ibase
07:41 ~ 07:45 -  이렇게 하는 것이 일반적인 규칙이다라는 거고요
07:45 ~ 07:48 -  그 다음에 변수를 만들 때는 var 이나
07:48 ~ 07:52 -  var 이나 아니면 val 을 사용을 하게 되는데요 이럴 때는 변수명하고 VAR, VAR, VAL을 사용하게 됩니다.
07:52 ~ 08:00 -  이럴때는 변수명과 콜론을 붙여서 콜론을 사용합니다.
08:00 ~ 08:04 -  여기에 이거랑 구분된다고 보시면 되겠죠.
08:04 ~ 08:10 -  그리고 여기에 있는 class, object, 변수 이런 것들은
08:10 ~ 08:14 -  명사로 만들어 주면 좋을 것 같고요.
08:14 ~ 08:17 -  반면에 function, fn은 function인데요.
08:17 ~ 08:21 -  이 function은 동사로 만들어주는 것이 좋겠습니다.
08:21 ~ 08:26 -  이 변수와 function은 첫 글자를 소문자로 만들어주면 되겠구요.
08:26 ~ 08:30 -  그 다음에 factory function 같은 경우에는 첫 글자
08:30 ~ 08:34 -  대문자로 만들어 줘라 이런 것도 이름 규칙에 들어 있습니다
08:34 ~ 08:42 -  그 다음에 const는 constant로 만들 때는 const val로 만들 때는 모두 대문자를 쓰고
08:42 ~ 08:47 -  underbar를 사용하는 것이 좋겠다는 것이 규칙에 정해져 있구요
08:47 ~ 08:55 -  그 다음에 block을 시작할 때 어떤 분들은 block을 내려 가지고 한 줄을 더 잡아먹는 그냥 한 줄만 달랑 잡아먹는
08:55 ~ 09:00 -  여는 중괄호를 그냥 한 줄만 블록 시작을 한 줄을 잡아먹는 게 있는데 그렇게 하시면
09:00 ~ 09:06 -  줄의 끝에 레이스를 열고 중괄호를 열고 그 다음부터 계속 쓰고
09:06 ~ 09:11 -  마지막에 붙일 때는 우리가 쓰는 일반적으로 쓰는 거 이렇게 쓰라는 거죠
09:11 ~ 09:15 -  이렇게 이미 이렇게 하고 계신 분들 많으실 테니까요
09:15 ~ 09:20 -  이거는 나중에 소스 코드 보시면 금방 적용이 되실 거라고 생각이 됩니다
09:21 ~ 09:30 -  자 그 다음에 클래스 라고 하는 건데요 이거는 음 여러분들 그냥 자반 아니면 10% 에서 많이 보셨던 거기 때문에 똑같이 그냥 클래스
09:30 ~ 09:34 -  라고 쓰시면 되겠구요 거부감이 없구요 자바의 익스텐즈 라고 하는 것 대신에
09:34 ~ 09:43 -  10++에서 사용했던 콜론을 사용하게 됩니다 그래서 아까 말씀드린 대로 이 콜론 앞뒤에 스페이스를 넣어 주면 좋다고 했죠
09:40 ~ 10:00 - Java나 C++와 같은 키워드 사용 Java의 extends 대신 C++의 간결한 : (콜론) 콜론 앞뒤에 space 상속받을 클래스 구현할 인터페이스를(콤마)로 구분하여 :(콜 론) 뒤에 나열 예제 MainActivity : AppCompatActivity() { 클래스는 AppCompatActivity 클래스로부터 상속 받 음 클래스 정의 앞에는 open이 붙어 있을 것임 실제로는 클래스임 클래스의 생성자는 파 라미터 없는 생성자 호출 5
09:43 ~ 09:53 -  자 그 다음에 상속받을 클래스 하고 구현할 인터페이스를 컴마로 구분해해서 콜론 뒤에 넣어주시면 됩니다.
09:53 ~ 09:55 -  여기에는 지금 interface는 없는데요.
09:55 ~ 09:57 -  만약에 interface가 있다고 했을 경우에는
09:57 ~ 10:00 -  여기다가 콤마 한 다음에
10:00 ~ 10:04 -  onClickListener 이런 식으로 써 주시면 된다는 거죠
10:04 ~ 10:09 -  이제 보시면 이렇게 클래스 쓰시고요 다 이해되시죠? 여기 main 쓰시고 여기에
10:09 ~ 10:17 -  app-compat-activity 있는데 이상한 것은 여기 이렇게 괄호 붙은 것만 좀 이해가 안되실 수 있겠네요
10:17 ~ 10:23 -  이 괄호가 붙어 있다는 건 뭐�은요. MainActivity 클래스 생성자가
10:23 ~ 10:25 -  여기 AppCompatActivity 클래스에
10:25 ~ 10:30 -  파라미터가 아무것도 없는 이런 생성자를 호출해 주겠다는 것을
10:30 ~ 10:37 -  의미해주고 있는 겁니다. 그리고 지금 이렇게 app-compat-activity
10:37 ~ 10:41 -  라고 부르는데요. 여기서 지금 상속을 받고 있는데 이렇게 상속을 받으려면
10:41 ~ 10:46 -  app-compat-activity 라는 곳에 가보면 거기 앞에 open-class 라고 오픈이
10:46 ~ 10:49 -  붙어 있을 거다 라는 거죠. 근데 여러분이 따라가 보시면 실제로는
10:49 ~ 10:51 -  자바 클래스입니다. 그래서 오픈이 붙어 있지는 않지만요. 여러분이 따라가 보시면 실제로는 자바 클래스입니다.
10:51 ~ 10:53 -  그래서 오픈에 붙어 있지 않지만요.
10:53 ~ 10:56 -  여러분이 전부 다 코트리는 프로그램을 짜실 때는
10:56 ~ 11:00 -  만약에 나중에 다른 클래스에서 상속 받겠다 했을 때는
11:00 ~ 11:11 -  그 다음에 클래스에 있는 그 constructor들인데요. 생성자들인데요.
11:11 ~ 11:19 -  보통의 경우에는 클래스 이름이랑 똑같이 만들어 줬었는데요.
11:19 ~ 11:21 -  kotlin에서는 그렇게 사용하지 않습니다.
11:20 ~ 11:40 - constructors 이름 뒤에 괄호를 붙이지 않고 constructor 키워드 MyView View primary constructor(ontext: Context) this(context, attrs: null) 없음 Context, AttributeSet?) attrs, defStyleAttr: 0) AttributeSet?, Int) super(context, defStyleAttr) 총 3개의 생성자 가장 마지막의 3개 파라미터 받는 것이 super 클래스(View)의 생 성자 Primary header에 이름 뒤에 정의 init 인스턴스 생성할 때실행됨 6
11:21 ~ 11:24 -  그래서 아예 이 constructor 라고 하는 키워드를 사용하는 거죠.
11:24 ~ 11:27 -  constructor가 아니고 constructor가 없죠.
11:27 ~ 11:30 -  constructor라고 하는 키워드를 사용합니다.
11:30 ~ 11:39 -  사용해줍니다. 그래서 이런식으로 constructor 하고 괄호 열고 그 다음에 이렇게 써주는 이런 형식으로 되어 있는 거죠
11:39 ~ 11:48 -  자 앞에서는 여기다가 앞에 클래스 이름이 메인 액티비티가 나오고 colon 하고 app-compat-activity 하고 괄호 열고 닫고가 있었는데요
11:40 ~ 12:00 - Lttrs,
11:48 ~ 11:52 -  여기서는 지금 괄호 열고 닫고가 없네요.
11:52 ~ 11:56 -  그리고 대신에 여기에 super를 불러주는 이런 형식으로 되어 있고요.
11:56 ~ 12:00 -  그 다음에 이 클래스 헤더에다가
12:00 ~ 12:05 -  생성자 라고 하는게 있는데 클래스 이름 뒤에 아예
12:00 ~ 12:20 - 생성자 I
12:05 ~ 12:09 -  constructor 를 만들어 줄 때는 이 constructor 라는 걸 또 지워도 됩니다.
12:09 ~ 12:14 -  만약에 여기에 myview 해가지고 여기에 뭔가 괄호가 있고 쭉 뭐가 있고
12:14 ~ 12:19 -  블록이 나온다 그러면은 아 이거는 constructor 구나 이렇게 하시면 되겠죠.
12:19 ~ 12:22 -  지금은 primary 생성자가 없습니다.
12:22 ~ 12:24 -  예제 한번 보시면요.
12:24 ~ 12:30 -  예제는 지금 총 3개의 Constructor를 만들고 있는데요.
12:30 ~ 12:38 -  제일 밑에 있는게 진짜입니다. 그래서 원래 이렇게 세 가지가 들어가게 되는데 이 세 개를 갖다가 받은 다음에 그거를 super를
12:38 ~ 12:47 -  이렇게 불러주는 것을 보여주고 있죠. 나머지는 지금 여기에다가 만약에 두 개짜리를 constructor를 불렀다 라고 했을 경우에는
12:40 ~ 13:00 - super(conte,
12:47 ~ 12:54 -  이 자기 자신의 constructor 이 세 개짜리 있죠. 거기에 default 값을 0으로 넘겨서
12:54 ~ 13:00 -  이 3개짜리를 불러주는 것을 보여주고 있구요 default 값은 여기 equal
13:00 ~ 13:05 -  이렇게 써 있을 때 디폴트 값이구요 3개의 짜리를 0을 넣어서 불러주는 거구요
13:05 ~ 13:08 -  2개 짜리에서 3개 짜리를 불러주는 거라고 보시면 되겠구요
13:08 ~ 13:13 -  여기에 보시면 얘는 1개만 준 거죠 그러면 여기에서 여기다 너를 집어 넣어 가지고
13:13 ~ 13:16 -  두 번째 너를 불러 줘 가지고 요거를 불러주는 겁니다
13:16 ~ 13:21 -  그러니까 만약에 이렇게 하나만 넣었다고 하면 여기서 얘를 불러주고 여기서 얘를 불러주는
13:20 ~ 13:40 - L ontext,
13:21 ~ 13:26 -  그리고 나서 여기에서 Superclass에 있는 생성자를
13:26 ~ 13:30 -  불러준다 이렇게 보시면 되겠죠.
13:30 ~ 13:39 -  이 인스턴스를 생성할 때 실행이 되어 초기화 처리를 할 수 있도록 되어 있습니다.
13:40 ~ 14:00 - 상속 최상위 Any 명시하지 않아도 암시적으로 상속됨 equals(), toString(), hashCode()과 확장 함수 언어의 철학은 명시적으로 만드는 것임 재정의 가능 멤버에 open 명시적으로 붙여줘야함 C++에서는 virtual로 override 혼용 Super 는 open, subclass 한 sub 클래스에서 더 이상 자신의 재정의하지 못 하게 하려면 final Overriding 에서도 open, 에서 open인 fun만 subclass 가능 7
13:41 ~ 13:53 -  상속이라고 하는 것을 보면 최상위 클래스는 Any라고 되어 있습니다. 그래서 이것은 아무것도 지정을 하지 않고 그냥 클래스를 만들어도
13:53 ~ 14:00 -  any에서 상속받은 걸로 되구요 여기에 equals 라든지 toString 그 다음에 hashCode 이렇게 세가지
14:00 ~ 14:03 -  이 메소드를 갖고 있는 것입니다.
14:00 ~ 14:20 - equals(), toString0, hash(Code()과 확장 함수
14:03 ~ 14:06 -  여기다가 확장함수라고 하는 개념이 있는데요.
14:06 ~ 14:09 -  따로 설명은 드리지 않지만
14:09 ~ 14:12 -  클래스 이름을 점으로 해서 함수를 확장할 수 있어서
14:12 ~ 14:15 -  상당히 편리한데요.
14:15 ~ 14:18 -  그런 것들로 여러가지 함수들이 들어 있습니다.
14:18 ~ 14:25 -  사용할 수 있습니다. 코틀린 언어를 만들 때 철학은 명시적으로 만드는 것이었다고 합니다.
14:20 ~ 14:40 - final-override
14:25 ~ 14:30 -  그래서 제정이 가능한 멤버의 오픈을 명시적으로
14:30 ~ 14:38 -  붙여줘야 된다 라고 했네요. 그러니까 클래스를 설계를 할 때 어 이거는 상속된 클래스에서
14:38 ~ 14:45 -  그 서브 클래스에서 가져다 쓸 수 있는 멤버다 라고 하면 거기다가 앞에다가 open을 붙여주라고 되어 있구요
14:40 ~ 15:00 - 명시적으로 만드는
14:45 ~ 14:54 -  만약에 그걸 가져다 쓰는 데서 여기에서는 가져다 쓸 때는 override 라고 하는 것을 써라 라고 되어 있는 거죠
14:55 ~ 15:00 -  C++ 에서는 virtual 이라고 하는 것을 가지고
15:00 ~ 15:04 -  제일 처음에 virtual이 있으면 그 뒤에는 virtual을 안 써도 virtual 함수 가상함수가 됐었죠.
15:05 ~ 15:09 -  자바 같은 경우에는 계속 전부 다 다 모듈함수를 다 dynamic binding 하니까
15:09 ~ 15:11 -  이런 virtual 키워드가 필요 없었죠.
15:12 ~ 15:16 -  superclass에는 open, subclass에는 override를 사용을 한다 라고 되어 있고요.
15:16 ~ 15:18 -  같은 개념인 거죠.
15:18 ~ 15:20 -  그 다음에 오버라이딩 할 때도
15:20 ~ 15:23 -  superclass에서 open이라고
15:23 ~ 15:25 -  fenu function인데요.
15:25 ~ 15:27 -  만약에 function 앞에 open을 붙여놨다 그러면
15:27 ~ 15:30 -  subclass에서는 override라고 하는 것을
15:30 ~ 15:33 -  사용하시면 되겠죠
15:35 ~ 15:41 -  오버라이딩 중요하니까요 상속하고 오버라이딩이 제일 중요합니다
15:40 ~ 16:00 - (overriding) super: (base) 의미 super를 사용해 의 해당 함수 호출 onCreate(savedInstanceState: Bundle?) super.onCreate(savedInstarceState) @outer 클래스이름 inner 인 경우에 outer class의 이름지정가능 super< 또는 인터페이스 이름>.멤버0 클래스 및 구현하는 interface의 멤버 이름이 같을 때 구분 가 능 8
15:41 ~ 15:45 -  상속하고 재정이 오버라이딩을 보는데요
15:45 ~ 15:49 -  super 라고 하는 것을 사용하는데 이 super 라고 하는 것은
15:49 ~ 15:52 -  super 클래스, 베이스 클래스를 의미하게 됩니다.
15:52 ~ 15:54 -  그래서 super를 사용해서
15:54 ~ 15:56 -  super 클래스에
15:56 ~ 15:58 -  해당 함수를 호출하는 거죠.
15:58 ~ 16:00 -  예제를 한번 보시면요.
16:00 ~ 16:08 -  여기에 지금 메인 액티비티라고 하는 것은 앱 컴팻 액티비티라고 하는 함수에서 상속받아 가지고 만들었는데요.
16:00 ~ 16:20 - 같을 때 구분 가
16:09 ~ 16:12 -  거기에 onCreate 라고 하는 이런 펑션이 있는데,
16:12 ~ 16:13 -  걔가 오버라이드 되어 있죠.
16:14 ~ 16:20 -  그러면은 이 앱 컴팻 액티비티라고 하는 것에 있는 onCreate가 불리지 않고,
16:22 ~ 16:25 -  자동으로 내가 만든 거에 있는 여기에 만든 이 onCreate를 불러주게 됩니다
16:25 ~ 16:30 -  그러다 보니까 이게 불리면은 app-compat-activity
16:30 ~ 16:42 -  여기에서 explicit하게 이렇게 super에 있는 onCreate를 부를 때 이렇게 super를 사용한다고 보시면 되겠습니다.
16:42 ~ 16:49 -  자 그 다음에 super하고 이렇게 n 마크를 쓰고 outer class 이름을 쓰는 경우가 있는데요.
16:49 ~ 16:52 -  만약에 inner class인 경우에 outer class 이름을 지 경우가 있는데요. 만약에 inner class인 경우에
16:52 ~ 16:54 -  outer class 이름을 지정할 때
16:54 ~ 16:58 -  이런 식으로 super, nmark, outer class 이름
16:58 ~ 17:00 -  이렇게 사용을 한다는 거
17:00 ~ 17:09 -  알아두도록 하시구요 그 다음에 수퍼 라고 하는거에 이렇게 꺽쇠를 써 가지고 클래스 아니면 인터페이스 이름을 쓰고 거기에 .member
17:09 ~ 17:18 -  를 이렇게 쓰는 경우가 있습니다 그래서 만약에 클래스 하고 구현하려고 하는 인터페이스 이름이 만약에 같을 때 두개 같다면
17:18 ~ 17:21 -  그냥 수퍼 라고 하면 어떤 건지 모를 테니까 이 멤버 그냥 super라고 하면 어떤 건지 모를 테니까
17:21 ~ 17:24 -  이 멤버 이름이 똑같다면 어떤 건지 모를 테니까
17:24 ~ 17:26 -  여기다가 이렇게 꺽쇠를 써 가지고
17:26 ~ 17:30 -  어떤 클래스, 어떤 인터페이스에 있는 멤버다라는 것을
17:30 ~ 17:35 -  구분할 수 있도록 이런 것을 문법을 제공해 주고 있습니다
17:37 ~ 17:44 -  자 그 다음에 좀 특이한 건데요 컴패니언 오브젝트 라고 하는 것을 제공을 하고 있는데
17:40 ~ 18:00 - companion static 인스턴스를 생성하지않아도 클래스를 통해 접근가능 Kotlin에서는 클래스에 오직 한 개의 가질 수 있음 AppCompatActivity(), View.OnClickListener const REQUEST GUNDAM = 100 KEY_NAME "name" } 다른 MainActivity.REQUEST GUNDAM과 같이 접근 9
17:44 ~ 17:51 -  음 저희가 인스턴스를 생성하지 않고 클래스를 통해서 접근할 수 있는 클래스 이름만 가지고도 접근할 수 있는
17:51 ~ 17:53 -  그런 스태틱이라고 하는 것을
17:53 ~ 17:55 -  우리가 흔히 사용을 하게 되는데요.
17:55 ~ 17:57 -  코틀린에서는 이런 스태틱이 없습니다.
17:58 ~ 18:00 -  스태틱을 사용할 수가 없습니다.
18:00 ~ 18:10 -  그래서 Kotlin에서는 클래스에서 딱 한개만 companion object를 만들었습니다.
18:00 ~ 18:20 - 에서는 Kotlin에서는 한 클래스에
18:10 ~ 18:16 -  companion object를 만들고, companion object를 만들면 에러가 나겠죠.
18:16 ~ 18:22 -  그래서 companion object를 가지고 있는 것을 보시면 가지고 있는 거라고 보시면 되겠구요.
18:20 ~ 18:40 - 한 클래스에
18:22 ~ 18:26 -  나중에 오브젝트 설명 들으시면 뭔가 이해가 되실 것 같구요.
18:26 ~ 18:30 -  이렇게 companion object라고 하는 동반 객체라고 번역이 되었고요.
18:30 ~ 18:36 -  동반 객체라고 하는 것을 사용을 한다는 것을 알아두시면 되겠습니다
18:37 ~ 18:46 -  자 그래서 여기 보면 const value 해가지고 우리 상수 쓸 때 main activity.requestUnderbar 건담 이런식으로 쓰게 되죠
18:40 ~ 19:00 - Kotlin에서는 한 wal
18:46 ~ 18:50 -  그러니까 그런걸 할 때 이런 companion object, 객�체를 만들지 않더라도
18:50 ~ 18:54 -  MainActivity.keyName을 사용하기 위해서
18:54 ~ 18:56 -  companion object를 만들고,
18:56 ~ 19:00 -  const value를 만들어서 쓰는 방법을
19:00 ~ 19:04 -  여러분들이 아마 필요하실 수도 있으니까 알아 두도록 하시구요
19:04 ~ 19:09 -  다른 클래스에서는 이렇게 가져다 쓴다는 거죠
19:10 ~ 19:18 -  자 그 다음에 오브젝트 라고 하는게 나왔는데요 아까 companion object 할 때가 오브젝트죠 그래서 이 오브젝트 라고 하는 것은
19:18 ~ 19:25 -  새로운 클래스를 만들지 않고 상속을 받아 가지고 재정의 할 때 주로 이 오브젝트를 많이 사용하게 됩니다.
19:20 ~ 19:40 - Functional Interface는 Lambda 식 새로운 를 만들지 상속받아서 재정의할 때 사용 anonymous 와 유사 예제, ImageLoader.ImageCache 에 대해 생성 별도 정의 없이 함수 내에서 인자로 구현 mimageLoader ImageLoader(mQueue, ImageLoader. ImageCache private cache LruCache<String, Bitmap>( maxSize: 20) getBitmap (url: String): Bitmap? return cache.get(ur1) putBitmap(ur1: String, bitmap: Bitmap) cache.put(ur1, bitmap) }) 10
19:25 ~ 19:30 -  자바에 있어서 자바 언어에서는 anonymous inner class
19:30 ~ 19:33 -  이런 것과 유사하다고 볼 수 있는데요.
19:33 ~ 19:38 -  그러니까 이름을 정하지 않고 클래스의 구현을 바로 만들 때
19:38 ~ 19:41 -  이렇게 우리가 anonymous 클래스를 많이 사용했었는데요.
19:40 ~ 20:00 - 를 만들지
19:41 ~ 19:47 -  그것처럼 여기서도 object라고 하는 것을 사용해서
19:47 ~ 19:55 -  object 한 다음에 이런 식으로 바로 여기다 이렇게 만들어 주는 이런 문법이 있습니다. 조금 이런 것은 좀 낯설 수 있겠죠. 이게 실제로 우리가 나중에
19:55 ~ 20:00 -  쓰게 될 그런 코드 인데요. 여기에 보시면은
20:00 ~ 20:07 -  object라고 하는 것을 써서 imageLoader라고 하는 클래스에 imageCache라고 하는 클래스가 있는데
20:00 ~ 20:20 - ImageLoader (mQueue, cache.get(url)
20:07 ~ 20:18 -  이 imageCache라고 하는 클래스를 여기서 구현을 해주고 있는 겁니다. 그래서 실제로 여기 지금 여기 콤마 있으니까 여기다 객체를 넘겨주는데 따로 클래스를
20:18 ~ 20:22 -  만들고 그거 인스턴셰이션 해고 인스턴스 만들고 주는 것이 아니라
20:22 ~ 20:25 -  바로 객체 자체를 만들 때 사용하게 되는 것입니다.
20:25 ~ 20:30 -  여기 보시면 functional interface는 람다식이 가능하다고 되어
20:30 ~ 20:35 -  지금 여기 보니까 뭘 만들어야 되는게 많이 있네요. 오버라이드 해야 될게 2개가 있네요.
20:35 ~ 20:43 -  그러다 보니까 얘는 사용할 수가 없는데요. 만약에 여기에 그 인터페이스 안에 함수가 하나만 딱 들어 있다. 그런걸 펑셔널 인터페이스 라고 부르는데요.
20:40 ~ 21:00 - LruCarthe<String,
20:43 ~ 20:51 -  아니면 뭐 sam 이라고 부르는데요. 그렇게 sam 이나 아니면 펑셔널 인터페이스인 경우에는는 이렇게 많이 쓸 필요 없이
20:51 ~ 20:55 -  그냥 바로 람다식으로 바로 지정을 할 수 있어 가지고
20:55 ~ 21:00 -  굉장히 편하게 쓸 수 있습니다.
21:00 ~ 21:03 -  보면서 말씀드리도록 하겠습니다.
21:04 ~ 21:13 -  그 다음에 데이터 클래스 라고 하는 건데요. 구글에서 이 코틀린을 처음 소개하면서 굉장히 자랑스럽게 했던게 기억이 납니다.
21:13 ~ 21:18 -  그래서 자바에서는 이만큼 긴거다 하고 소스코드를 자바 소스코드를 먼저 이렇게 보여줍니다.
21:18 ~ 21:21 -  그리고 나서 코틀린에서는 이거 한 줄이면 됩니다.
21:20 ~ 21:40 - data 구글에서 처음 소개하면서 자랑스럽게 보여줬던 영상에 나옴 "Java에서는 이만~큼 긴 소스 코드를 Kotlin에서는 단 한줄만 쓰면 됩니다." Default C++ struct도 접근 지정자가 Gundam (var model:String, var name:String, image:String) 개의 멤버 가짐 g= Gundam("RX-78-2", "건담", "건담.jpg")로 초기화 사용할 때는 g.model로 접근 가능 11 Institute,
21:21 ~ 21:24 -  그럴 때 사람들이 막 박수치고 이런 장면이 나오죠.
21:24 ~ 21:30 -  그러니까 그만큼 매번 우리가 쓸데없이 계속 많이 했던 그런 장면이
21:30 ~ 21:33 -  이것이 예제입니다.
21:33 ~ 21:36 -  이런식으로 쓰면 여기 constructor도 들어있고
21:36 ~ 21:39 -  getter, setter가 전부 다 들어있는 형태로 만들어지기 때문에
21:39 ~ 21:42 -  굉장히 간단하게 처리할 수 있겠죠.
21:40 ~ 22:00 - 개의 멤버 가짐
21:42 ~ 21:45 -  한 줄로 다 처리하니까 상당히 매력적이라고 볼 수 있겠죠.
21:45 ~ 21:48 -  여기에 있는 kotlin 언어는
21:48 ~ 21:51 -  default visibility가 public이라고 했죠. 만약에가 아니고 default visibility가 public이라고 했죠?
21:51 ~ 21:54 -  만약에가 아니고,
21:54 ~ 22:00 -  C++ 언어에 있는 struct 같은 것도 default 접근 지정자가 public이죠.
22:00 ~ 22:07 -  간혹 스트럭트와 클래스의 차이점에 대해서 얘기하라고 하면
22:00 ~ 22:20 - 단 한줄만 쓰면 publicr 접근 지정자가
22:07 ~ 22:12 -  면접실에 물어볼 수 있는데요. 스트럭트와 클래스의 유일한 차이는요.
22:12 ~ 22:19 -  디폴트 접근 지정자가 public이면 스트럭트고 디폴트 접근 지정자가 private이면 클래스입니다.
22:19 ~ 22:22 -  그렇게 얘기하시면 정답입니다.
22:22 ~ 22:25 -  예를 들면 상속이 안되고 그러면 틀리는 겁니다.
22:25 ~ 22:27 -  structure도 상속되고 다 똑같으니까요.
22:27 ~ 22:30 -  유일한 차이점은 default
22:30 ~ 22:35 -  접근 지정자가 struct는 public이다 라는거
22:35 ~ 22:41 -  몰라도 되는데요. 알아두시면 혹시나 면접에 그런 그런 면접
22:41 ~ 22:45 -  글쎄요. 별로 좋은 면접 같지 않은데요. 그런걸 물어보면 그렇게 대답하시면 될 것 같구요.
22:45 ~ 22:51 -  별로 쓸모는 없습니다. 자 예제 보시면 이렇게 데이터 클래스 해가지고요
22:51 ~ 22:54 -  거기에 건담이라고 돼 있고
22:54 ~ 22:57 -  여기에 이런 식으로 베리어블로 모델
22:57 ~ 23:00 -  그 다음에 네임 이미지
23:00 ~ 23:07 -  이런 것들을 가지고 있네요. 그래서 초기화 할 때는 이런 식으로 바로 그냥 건담 한 다음에 new도 없죠. 그래서 굉장히 편하죠.
23:07 ~ 23:17 -  건담해서 이렇게 초기화 하고요. 쓸 때는 여기 이게 변수를 만약에 G로 만들었다 그러면 G.model 하고 바로 접근할 수 있게 됩니다.
23:17 ~ 23:24 -  변수는 두 가지 종류가 있는데요. val 이라는 것과 var 이라는 것이 있습니다.
23:20 ~ 23:40 - 변수 두종류 read-only paint: Paint Paint() bmp: Bitmap 할당 가능 변수이름: 값을 초기화하는 경우에 값의 타입이 명확하다면 변수의타입을 지정하지 않아도 됨 ?(물음표)가 붙는 경우는 변수가 null을 가리킬 수 있는 nullable이라는 의미 Safety 참조 12
23:24 ~ 23:27 -  val 이라는 것은 read-only 변수이고
23:27 ~ 23:30 -  var 이라는 것은 할당이 가능한 변수입니다.
23:30 ~ 23:35 -  여기 보시면 얘는 제일 처음에 이렇게 초기화가 되어 있으면은
23:35 ~ 23:39 -  이것을 바꾸지 못하는 거고요. 그 다음에 var로 되어 있다 그러면
23:39 ~ 23:42 -  bmp에다가 다른 것들을 넣어 줄 수 있겠죠.
23:40 ~ 24:00 - 두 종류 bmb: 수 있는
23:42 ~ 23:46 -  자, type은 이렇게 변수 이름 다음에 콜론하고 한 칸 띄고
23:46 ~ 23:48 -  그 다음에 type이 나오는 거 보실 수 있고요.
23:48 ~ 23:52 -  자, 그 다음에 여기 뒤에 막 물음표 이렇게 붙어 있는 것들이 많이 있는데요
23:52 ~ 23:55 -  그런건 Nullable 이라고 하는 건 Null이 될 수 있다는 의미인데요
23:55 ~ 24:00 -  나중에 Null Safety 에서 보도록 하겠습니다
24:00 ~ 24:06 -  late init는 늦게 초기화한다는 뜻이겠죠. 그래서
24:00 ~ 24:20 - lateinit constructor() 초기화할 안써도 됨 Nullable일 때는 쓸 수 없음 isInitialized로 검사 Nullable이 아닌데 초기화 하지 않을 때사용 예제) mImageLoader 만들고 onCreate()에서 초기화 mimageLoader: onCreate (savedInstaneState: setContentView(R.layout.activity main) 13
24:06 ~ 24:14 -  컨스트럭터에서 초기화 할 때는 안 써도 되는데요. nullable일 때는 이걸 쓸 수가 없구요.
24:14 ~ 24:25 -  null이 들어갈 수 있는 거니까 지정 안 할 수 있으니까요. 그 다음에 isInitialized 이거로 검사가 가능합니다. 지금 초기화가 됐는지 안 됐는지
24:20 ~ 24:40 - constructor()에서 초기화 하지 않을때 사용 onCreate(savedinstanceStte:
24:25 ~ 24:30 -  만약에 nullable이 아닌데 그러니까 null이 들어가면 안 되는데
24:30 ~ 24:35 -  이것을 덧널이라고 하는데요. 그것을 초교하지 않고 만약에 사용을 했다
24:35 ~ 24:43 -  그럴 경우에 이런 식으로 rate init을 붙여 줘야 됩니다. 지금 여기서 rate init이라고 하는 것은
24:40 ~ 25:00 - lateini
24:43 ~ 24:49 -  먼저 그 queue를 만든 다음에, 지금 여기 소스 코드에는 queue가 없는데요.
24:49 ~ 24:51 -  queue를 만든 다음에
24:51 ~ 24:54 -  이것을 초기화 해줘야 되기 때문에
24:54 ~ 24:57 -  여기에다가는 이렇게 late init이라고 만들어 주고
24:57 ~ 25:00 -  그 다음에 다른 작업을 하고 나서 그때 초기화
25:00 ~ 25:03 -  이런식으로 쓴다고 보시면 되겠습니다.
25:03 ~ 25:06 -  late에 있는 키워드를 보시면
25:06 ~ 25:09 -  여기서는 초기화 안해도 나중에 초기화 하는거구나 라고 생각하시면 되겠죠.
25:09 ~ 25:12 -  그 다음에 함수인데요.
25:12 ~ 25:15 -  FUN이라고 이렇게 씁니다.
25:15 ~ 25:18 -  앞에 FUN을 붙여서 함수를 만들고요.
25:18 ~ 25:23 -  파라미터는 그냥 변수하듯이 이런식으로 변수 이름 콜론하고 타입 정해주시면 되겠고요.
25:20 ~ 25:40 - (function) 앞에 붙여야함 Parameter 선언과 같이 타입 형식 개일 때는 콤마(,)로 분리 Unit: 반환값 없음r Unit인 경우 생략 가능 getItemId(position: Int): Long position.toLorg() 반환 값은 타입이고 파라미터는 Int 하개를 갖는 getItemId() 함수 정의 14
25:23 ~ 25:27 -  그 다음에 이 함수의 반환값은 이렇게 콜론하시고
25:27 ~ 25:30 -  뒤에다 이렇게 타입을 써주시면 되는데
25:30 ~ 25:35 -  만약에 반환값이 없다고 했을 경우에는 unit, 여기 colon, unit이라고 쓰면 됩니다.
25:35 ~ 25:43 -  근데 이 unit인 경우에는 생략이 가능하니까 이게 뒤에가 colon하고 아무것도 없다 그러면 반환값이 없구나 라고 생각하시면 되겠죠.
25:48 ~ 26:00 -  예제를 보시면 여기에 반환값이 long이고 파라미터는 int 포지션 한 개를 갖는 get item id를 만들었다 라고
26:00 ~ 26:01 -  그렇게 보시면 되겠죠.
26:00 ~ 26:20 - Int 한 개를
26:03 ~ 26:05 -  자, default argument이라고 하는 게 있는데요.
26:05 ~ 26:08 -  이런 식으로 여기에 equal 해가지고 주게 되면은
26:08 ~ 26:11 -  사용자가 이 앞에 있는 한 개만, 원래 두 개죠? 두 개인데
26:11 ~ 26:13 -  하나만 불러도 자동으로 값이 들어가는 거고요.
26:13 ~ 26:17 -  named argument이라고 하는 것은 먼저 value가 integer 타입이고
26:17 ~ 26:20 -  text가 string 타입인데, 이거를 부를 때
26:20 ~ 26:23 -  이렇게 이게 뒤에 있는 걸 먼저 이렇게 써도 된다는 얘기죠.
26:20 ~ 26:40 - 함수 활용 Arguments 호출시에 않으면 값지정 myFunc(value: Int, text: String "") { } caller() myFunc( value: 100) Named IDE에서 회색으로 보여주는 것과 비슷하게 명시적으로 쓸 수 있 순서 바뀌어도 됨 myFunc(vale: String) {} myFunc(text="Hello" value=100) 15
26:23 ~ 26:26 -  text="hello", 이렇게 써도 된다는 얘기입니다.
26:28 ~ 26:30 -  자, 그 다음에 굉장히 유용한
26:30 ~ 26:36 -  string 템플릿을 많이 쓰게 될 겁니다. printf %d 같은 거라고 보시면 되는데
26:36 ~ 26:40 -  이거를 원래는 이렇게 쓰죠. 쌍따옴표하고 어쩌고 저쩌고 한 다음에
26:40 ~ 26:45 -  format%d 이런 게 들어간 걸 쓰고 쌍따옴표하고 컴마 한 다음에
26:40 ~ 27:00 - Templates 유용하게 사용할 수 있는 문법 printf()의 %d생각하면됨 따로 분리하지 않고 스트링 내에 집어넣음 $ 사용,{}도사용가능 holder.imImage.setImageUrl( url: "${SERVER_ URL}images/${mArray[positior].image}", mimageLoader) ; url 지정하는 두 번째 줄 ${SERVER _URL}의 내용이 스트링에 들어가고 바로 뒤이어 images/가 들어가며 그 뒤로 mArray의 poision번째에 저장된 image 스트링 값이 들어감 16
26:45 ~ 26:48 -  그 다음에 앞에 있는 거에 대해서 써주다 보니까
26:48 ~ 26:51 -  순서가 잘 안 맞으면 잘 안 나오거나 이런 문제가 있었는데요
26:51 ~ 26:52 -  그런 거를 이렇게 string template
26:52 ~ 26:54 -  또는 template string 이라고 하는 것을
26:54 ~ 26:55 -  사용을 하게 되면은
26:55 ~ 26:57 -  $ 하고 이런 중괄호
26:57 ~ 26:59 -  이런 거를 사용해 가지고
26:59 ~ 27:00 -  굉장히 편하게
27:00 ~ 27:04 -  예제 보시면 이 줄인데요. 여기에 server-url 이라고 하는 것이
27:04 ~ 27:08 -  server-underbar-url 이라고 하는 것이 const value이고요.
27:08 ~ 27:12 -  val 이고요. 그 다음에 여기에 marray 라고 하는 array를 만들어 놓은 겁니다.
27:12 ~ 27:17 -  그래서 이걸 쓸 때 이렇게 $ 하고 여기에는 지금 만약에
27:17 ~ 27:22 -  슬래시가 있었으면은 이거를 이렇게 중간으로 안 써도 되는데요.
27:20 ~ 27:40 - 사용,{}도 사용가능 "${SERVER_URL} images/${mArray[position].image}",
27:22 ~ 27:26 -  제가 이 Server URL을 만들 때, 구현을 할 때, 거기에 Slash를 넣었습니다.
27:26 ~ 27:30 -  그러다 보니까 Server URL 하고 아무것도
27:30 ~ 27:35 -  이미지 수는 전체를 변수 이름으로 인식을 하니까
27:35 ~ 27:39 -  이것을 구분하기 위해서 중괄호를 넣어준 거고요.
27:39 ~ 27:43 -  여기에 있는 것도 마찬가지로 mArray에 복잡한 것들이 나오니까
27:43 ~ 27:49 -  이것을 값을 계산할 수 있도록 넣어준 거라고 보시면 되겠습니다.
27:49 ~ 27:52 -  굉장히 편리하겠죠.
27:52 ~ 28:00 -  자 그 다음에 visibility modifiers 라고 하는 것이 클래스에 있는 비저빌리티 접근 지정자라고 생각합니다.
28:00 ~ 28:04 -  privacy는 현재 클래스에서만 보이고
28:00 ~ 28:20 - Visibility Modifiers in Classes 현재 내부에서만 보임 Outer 클래스에서도 못 봄 protected 모듈이 클래스 및 파생 클래스 개라면 public과 internal 동일 같은 모듈(같이 컴파일되는 코틀린 파일들의 집합) 안에서 멤버를 선언한 클래스를 볼 수 있다면 한 클래스 내부에 클래스가 있고 거기에 멤버가 있 다면 바깥의 클래스에서는 접근하지 못함 (default) 클래스를 볼 수 있다면접근 17
28:04 ~ 28:07 -  out 클래스에서도 못보는 거죠.
28:07 ~ 28:11 -  어떤게 바깥에 있고 안에 있는 거다 라고 하면
28:11 ~ 28:14 -  바깥에서 안에 있는 것을 참조 못하니까
28:14 ~ 28:19 -  java와는 다를 수 있으니까 주의하도록 하시고요.
28:19 ~ 28:21 -  그렇게 쓸 일이 잘 없기는 하고요.
28:21 ~ 28:25 -  그 다음에 protected 라고 하는 것은 현재 클래스하고 파생 클래스에서 쓰는 게 있고요.
28:25 ~ 28:30 -  public 은 그냥 다 쓰는 거니까
28:30 ~ 28:34 -  특이하게 internal이라는 것이 있습니다.
28:34 ~ 28:37 -  internal이라는 것은 모듈이라는 개념이 나오는데
28:37 ~ 28:41 -  보통 우리가 쓰는 게 그냥 모듈이 한 개 짜리여서
28:40 ~ 29:00 - 같은 모듈 (같이 컴파일되는
28:41 ~ 28:43 -  public하고 비슷하다고 보시면 되는데
28:43 ~ 28:47 -  만약에 모듈을 여러 개로 구성을 만들어 가지고 구성을 했다
28:47 ~ 28:51 -  라고 했을 때는 internal 멤버를 선언한 클래스
28:51 ~ 28:54 -  이것을 볼 수 있다면 접근이 가능하다고 했는데요
28:54 ~ 29:00 -  이 인터넷 멤버를 선언한 클래스를 아예 볼 수 없는 경우 그러면 이때는
29:00 ~ 29:06 -  어차피 접근할 수가 없겠죠. 자, 얘도 마찬가지로 public 이라고 하는 것도 무조건 다 보는게 아니구요.
29:00 ~ 29:20 - 같은모듈(같이 컴파일되는
29:06 ~ 29:14 -  public 멤버를 선언한 클래스를 볼 수 있다면 접근 가능하다는 거, 무슨 말인지 모르시면 그냥 넘어가도 되겠습니다.
29:14 ~ 29:22 -  자, 그 다음에 중요한 것은 null 안정성 이라고 하는 건데요. 이 null 안정성이라고 하는 것입니다.
29:20 ~ 29:40 - 안전성 null pointer exception 발생제거노력 C++, Java 언어에는 특이한 변수는 크게 두 가지 종류: non-null nullable Non-null 가질 수 없는 변수 가질 수 없으므로 NPE 발생하지 않음 설명 Nullable 수 있는 변수 객체의 함수를 실행하는 경우null반환 C++, Java의 발생하고프로그램종료 18
29:22 ~ 29:30 -  Kotlin에서는 Null Pointer Exception을 우리가 흔히 프로그램을 짜다가 많이
29:30 ~ 29:36 -  발생하는 거죠 그래서 어플리케이션이 그냥 죽어버리면 굉장히 골치 아픈데요 이거를 발생을
29:36 ~ 29:45 -  np 라고 줄여서 씁니다. 그래서 np 를 발생하는 것을 제거하기 위해서 노력을 했습니다. 그래서 c++ 나 자바 없이 물음표
29:40 ~ 30:00 - NPE발생하지않음 경우 null 반환
29:45 ~ 29:52 -  이런 것들이 많이 들어가게 되는데요. 변수는 두 가지 종류로 null 하고, null로 나눌 수 있습니다.
29:52 ~ 29:56 -  넌, 널은 null을 가질 수 없는 변수이니
29:56 ~ 30:00 -  null을 저장하지 못하게 컴파일러가 막아버릴 수 있습니다.
30:00 ~ 30:04 -  null 포인트 exception이 발생할 수가 없죠.
30:04 ~ 30:06 -  아예 발생할 수가 없고요.
30:06 ~ 30:08 -  그 다음에 nullable인 경우에는
30:08 ~ 30:10 -  이럴 경우에는 문제가 될 수 있는데요.
30:10 ~ 30:12 -  이게 어떻게 해결을 했냐면
30:12 ~ 30:14 -  null 객체의 함수를 실행할 경우에는
30:14 ~ 30:16 -  바로 그냥 null을 반환하도록
30:16 ~ 30:19 -  이런 옛날에 랭기지가 프로그래밍 언어가 있었는데요.
30:19 ~ 30:21 -  아무것도 없는 것한테 메시지를 보내면
30:20 ~ 30:40 - NPE 발생하고 프로그램 종료
30:21 ~ 30:23 -  아무것도 하지 않으니까 아무것도 없는 거다.
30:23 ~ 30:26 -  이런 개념인 거죠.
30:26 ~ 30:30 -  자, 근데 Java나 C++ 같은 경우에는
30:30 ~ 30:38 -  예를 들면, method를 불렀는데 p가 null이다 그러면은 거기서 프로그램이 종료해 버리죠
30:39 ~ 30:48 -  nullable 이라고 하는 것은 레퍼런스에 null이 들어갈 수 있다면 nullable 이라고 명시를 해줘야 됩니다. 그러니까 null이 들어갈 수 있느냐 없느냐를 해줘야 되는데요
30:40 ~ 31:00 - Reference에 들어갈 있다면 nullable이라고명 시해 줘야함 오른쪽에 ?(물음표) str: String? Elvis 연산자?: null일 뒤의 표현식 반환 (또는 throw로 발생) val len: Int?=str?.length?: -1 !! null이 아님이 확실하거나 발생시킬 때 사용 as? (Safe cast 연산) 타입으로 cast가 불가능하다면 len: Int? = arg 19
30:48 ~ 30:50 -  type 오른쪽에 물음표를 붙여주면 됩니다.
30:50 ~ 30:53 -  그래서 만약에 이렇게 variable을 만드는데요.
30:53 ~ 30:55 -  얘는 재할당이 가능한 거네요.
30:55 ~ 31:00 -  거기 str에 str이라고 하는 게 이름인데 거기에 string하고
31:00 ~ 31:07 -  물음표를 썼다고 했을 경우에는 str은 null을 가리킬 수 있다고 보시면 되겠습니다
31:00 ~ 31:20 - 들어갈 수
31:07 ~ 31:17 -  자 그 다음에 특이한 엘비스 연산자 라고 하는 거 이게 뭐 엘비스 머리를 닮았다고 해서 그랬다고 했던가요 뭐 그래서 이렇게
31:17 ~ 31:22 -  이름을 재밌게 붙였는데요 여기 물음표 � 콜론이라고 하는 건데 상당히 유용합니다.
31:20 ~ 31:40 - 연산자?
31:22 ~ 31:27 -  그래서 널일 경우에는 이 콜론 뒤에 있는 거를 반환해 주는 겁니다.
31:27 ~ 31:30 -  그래서 예를 들면 예제를 보시면 쉽게 아실 텐데요.
31:30 ~ 31:36 -  만약에 여기 length라고 하는 것이 nullable로 이렇게 만들었죠.
31:36 ~ 31:41 -  그런 다음에 이거를 원래는
31:41 ~ 31:50 -  여기에다가 이 len이라고 하는 변수에다가 string 값이 만약에 null이 아니라면 length를 넣어주고요.
31:50 ~ 31:53 -  만약에 string이 null이다 라고 했을 경우에는
31:53 ~ 31:56 -  여기 이렇게 "-1을 넣어주는 그런 코드입니다
31:56 ~ 31:57 -  이해가 되시나요?
31:57 ~ 32:00 -  그러니까 여기다 이게 널러버리니까요
32:00 ~ 32:04 -  그러니까 아 여기에다가 이거는 지금 인트 이거는 상관이 없겠네요
32:00 ~ 32:20 - Int?=stri?.length?:
32:04 ~ 32:10 -  인트의 물음표는 지금 상관이 없겠구요 str 의 물음표 라고 하는 것이 널러
32:10 ~ 32:16 -  부리니까 여기 점 랭스 라고 하는 거에서 만약에 스트링이 널이면 보통 여기서
32:16 ~ 32:21 -  죽잖아요 프로그램이 근데 여기서는, 코틀린에서는 그렇게 하지 않고
32:20 ~ 32:40 - Int?=strp.length?:
32:21 ~ 32:24 -  str이 null이냐 물어보고
32:24 ~ 32:28 -  이게 만약에 null이 아니라면 length를 반환해주고요.
32:28 ~ 32:30 -  그 다음에 만약에
32:30 ~ 32:33 -  str 자체가 null이라면
32:33 ~ 32:36 -  "-1을 넣어준다고 하면 되겠네요
32:36 ~ 32:39 -  여기에 물음표를 띄는게 좋겠네요
32:39 ~ 32:42 -  자 이렇게 지우는게 나을 것 같습니다
32:40 ~ 33:00 - Int=str?.length?: NPE발생시킬때사용
32:42 ~ 32:45 -  자 그 다음에 이런 연산자도 있습니다
32:45 ~ 32:48 -  느낌표 느낌표라고 하는건데요
32:48 ~ 32:51 -  이거는 null이 아닌게 확실하다라고 할 때 그 다음에 아니면 null이면 null 포인트 이섹션을 발생시�실하다 라고 할 때 그 다음에 아니면은 null이면은
32:51 ~ 32:54 -  null 포인트 이섹션을 발생시켜라 라고 할 때
32:54 ~ 32:58 -  이런 식으로 넣어주게 됩니다
32:58 ~ 33:00 -  null 체크를 한 뒤면은
33:00 ~ 33:05 -  이걸 넣어 줘도 되겠죠. 자 그 다음에 as 하고 이런식으로
33:05 ~ 33:13 -  물음표 라고 하는게 있는데요. saveCast 연산이라고 하는데 다른 타입으로 캐스트가 불가능하다면 너를 반환해 주는 겁니다.
33:13 ~ 33:21 -  그래서 여기에 만약에 ran 이라고 하는게 있는데요. 만약에 arg라고 하는 것이
33:21 ~ 33:30 -  만약에 이걸 바꿀 수가 없다 인테이저로 바꿀 수가 없다 그러면은 너를 반환을 해 주니까 이 ran이라고 하는 것은 너를 갖게 되는거죠
33:30 ~ 33:42 -  이런식으로 Nullable에 관련되어 여러가지 것들이 있으니까요 여러분들이 차근차근 나중에 보도록 하시면 되겠구요
33:40 ~ 34:00 - NetworkImage View 사용시 개발자 문서의 코드에서 실행시 에러 발생 getBitmap()의 Bitmap을 Nullable로 변경하면 해결됨 getBitmap(url: 20
33:42 ~ 34:00 -  여기 보시면 네트워크 이미지 뷰를 사용할 때 나중에 우리가 만들어 볼 건데요 이런게 있었습니다. 실제로 개발자 공식문서에 코드를 가져다 썼는데요. 실행시 에러가 발생했습니다.
34:00 ~ 34:11 -  그래서 get bitmap이 nullable로 바꿔야지만 해결이 되는게 있었는데요.
34:11 ~ 34:15 -  그럴 때 이런식으로 뒤에 물음표 붙여주면 됩니다.
34:15 ~ 34:18 -  나중에 배울 때 말씀드리면 될 것 같구요.
34:18 ~ 34:21 -  그 다음에 lambda expression이라고 하는 것
34:20 ~ 34:40 - Expression Anonymous functions 붙지 구현만 있음 식만 함수 인자로 전달한다면괄호생략 예제: test({doit()}) test doit() } it: lambda 식이 parameter 만 갖는다면 ->를 생략하 고 이름은 it 사용 SAM (Single Abstract Method) interface interfac에 method 개인 (많음) 예제에서는 onClick() button.setOnlickListener View! btn Button it as textView.text btn.text ) 21
34:21 ~ 34:23 -  들어오는 보셨죠? lambda expression
34:23 ~ 34:26 -  이거는 뭐냐면은 anonymous function 같은 거
34:26 ~ 34:30 -  이름이 붙어 있지 않은 그런 함수 구현만 되어 있는
34:30 ~ 34:35 -  그래서 람다식만 만약에 함수 인자로 전달한다면은
34:35 ~ 34:44 -  괄호를 생략 가능하다고 되어 있는데요 이런 식으로 테스트 괄호 열고 그 다음에 다시 또 그렇게 식이 들어간다 라고 했을 경우에는 이
34:40 ~ 35:00 - 식만 함수 인자로 전달한다면 괄호 생략 가능 T ->를 생략하 개인경우
34:44 ~ 34:49 -  괄호를 빼 가지고 이런 식으로 쓸 수 있다는 거죠
34:50 ~ 35:00 -  자 그 다음에 is 이라고 하는게 있는데요 람다 식에서 만약에 1개의 파라 파라미터 만 갖고 있다라고 그러면은 그거를 어 보통은 뭐 부위
35:00 ~ 35:05 -  그 다음에 마이너스 꺽수에 이렇게 해서 어떤 파라미터를 갖는지를 써줘야 되는데요
35:00 ~ 35:20 - 갖는다면I->를 생략하
35:05 ~ 35:12 -  만약에 하나만 있다 그러면 그걸 쓰지 않고 그냥 it이라고 그 블록 내에서 it이라고 써주면 된다는 얘기죠
35:12 ~ 35:23 -  자 여기에 보시면 이렇게 it이라고 하는 게 있고 콜론하고 view 해가지고 느낌표 이렇게 되어 있는데요 여기에 보시면 지금 이렇게 회색으로 되어 있는 것들은 제가 타이핑을 하는 것이 아닙니다.
35:20 ~ 35:40 - its
35:23 ~ 35:30 -  자동으로 아이디에서 안드로이드 스튜디오에서 이렇게 넣어 주는 거라고 보시면 되겠죠. 그래서 it이 있다고 알려주는 거죠.
35:30 ~ 35:36 -  자 그런 다음에 SEM, Single Abstract Method Interface 라고 하는 것이 있는데
35:36 ~ 35:41 -  인터페이스의 메소드가 딱 한 개인 경우, 근데 이런 경우가 굉장히 많습니다.
35:41 ~ 35:48 -  여러분이 인터페이스를 만들었는데 메소드를 여러 개 만들었지 않았을까? 이렇게 생각을 하는데 실제로 하나인 경우가 굉장히 많거든요.
35:48 ~ 35:52 -  그래서 이렇게 하나만 있을 때 이런걸 S SAM 인터페이스라고 부르는데
35:52 ~ 35:54 -  또는 Functional Interface라고 부르는데
35:54 ~ 35:56 -  이럴 때는 람다식으로 가능합니다.
35:56 ~ 35:58 -  원래는 어떻게 되냐면은
35:58 ~ 36:00 -  버튼의 set
36:00 ~ 36:04 -  onClickListener 한 다음에 여기다 오브젝트 만들어서
36:00 ~ 36:20 - :Button
36:04 ~ 36:09 -  onClickListener를 구현해 주고 그걸 넘겨 줘야 되는데 그냥 람다식으로 바로
36:09 ~ 36:13 -  넘겨 줄 수 있으니까 함수에 구현한 것을 인자로 넘겨줄 수 있으니까 굉장히
36:13 ~ 36:17 -  편하다고 보시면 되겠죠
36:18 ~ 36:23 -  람다식에는 이런 underbar 라고 하는 것을 사용할 수 있는데요
36:20 ~ 36:40 - 식에서의 (Underbar) 사용하지 않는 에는 이름을 부여하지 않고 붙여서 자리만 차지 listView.setOnItemClickL.istener adapterView, view, i,1-> listView.set:OnItemClickL.istener → i, -> Toast.makeText( context: this, mArray[i].name. Toast.LENGTH_SHORT).show() 리스트에서 Item Click에 대한 리스너를 식으로 구현 4개의 파라미터가 있지만 구현할 때는 3번째의 몇 번째 아이템 이 선택되었는지만 필요하여 나머지는 숫자에서 읽기 쉽게 자리 구분 22
36:23 ~ 36:26 -  만약에 우리가 필요가 없는 것, 원래는 이렇게 써야 되는 겁니다
36:26 ~ 36:30 -  예제를 보시면 setOnItemClickListener면
36:30 ~ 36:37 -  이렇게 4개가 원래는 다 지정이 돼야 되는 거죠 근데 이 중에서 우리가 이 람다식대에서 얘네를 사용하지 않습니다
36:37 ~ 36:46 -  하나 둘 세 번째 것만 쓰고 네 번째 첫 번째 두 번째 네 번째 건을 사용하지 않는다 그러면은 이런식으로 언더바로 이렇게 만들어 주시면 되는 거죠
36:40 ~ 37:00 - listView.setnItemClickListener 1 mArray[i].name
37:00 ~ 37:03 -  밑줄은 언제 또 유용하냐면요
37:00 ~ 37:20 - ,
37:03 ~ 37:07 -  숫자에서 읽기 쉽게 하기 위해서
37:07 ~ 37:10 -  예를 들면 1000단위, 100만단위 이렇게
37:10 ~ 37:13 -  언더바를 써주면
37:13 ~ 37:16 -  그게 숫자가 예를 들면 3000이다 그러면
37:16 ~ 37:20 -  3 언더바 0 0 0 이런 식으로 지원을 해줍니다
37:20 ~ 37:25 -  그래서 우리가 읽기가 굉장히 편하죠 0이 많거나 숫자가 길면은
37:20 ~ 37:40 - mArray[i].name,
37:25 ~ 37:29 -  몇백만
37:30 ~ 37:41 -  몇백 몇십만 이렇게 해서 우리가 읽어야 되는데 굉장히 힘들죠. 그래서 언더바 있으면 그런 것들을 읽기가 편해질 겁니다.
37:40 ~ 38:00 - when 범위도 처리 switch-case 문 생각하면 됨 다른 언어에 비해 강력함 변수에서 (v?.id) btnGundam.id intent.putExt:ra(KEY_NAME, "RX-78-2") btnZaku.id "MS-06S") 스트링도처리예제 (intent.getstringExtra ("name ")) "RX-78-2" > imageView2.setImageResource (R.drawable.rx782) "MS-06S" imageView2.setImageRessource (R.drawable.ms06s) else (R.drawable.ic launcher background) 23
37:41 ~ 37:47 -  그 다음에 when 이라고 하는 것은 스위치 케이스 문장이라고 보시면 되겠는데요.
37:47 ~ 37:53 -  이거는 예제 보시면 아마 쉽게 보실 텐데 굉장히 강력합니다.
37:53 ~ 38:00 -  그래서 integer 처리할 때는 이렇게 when 해서 v? 이렇게 되어있는 것은 nullable 이라
38:00 ~ 38:05 -  그래서 이게 만약에 v가 null 이라고 하면 null인 경우에 리턴을 하게 되는 거구요
38:00 ~ 38:20 - (va.id) (intent.getStringExtra
38:05 ~ 38:14 -  만약에 null이 아니다 그러면 여기 id 이걸 가지고 다른 거랑 맞아서 이거다 그러면 여기 이렇게 마이너스 하고 꺽쇠 화살표 모양으로 되어 있는 이
38:14 ~ 38:19 -  오른쪽에 있는 걸 실행을 해주고요 지금 여기서 한 줄만 있는데 만약에 여러 줄을 해야 된다 그럼 이거를
38:19 ~ 38:22 -  블록으로 만들어어주시면 되겠습니다
38:22 ~ 38:24 -  그 다음에 정말 막강한게 이런거죠
38:24 ~ 38:27 -  이것 말고도 많이 있는데요
38:27 ~ 38:30 -  스트링 이런것도 처리가 가능합니다
38:30 ~ 38:37 -  string을 가져왔다면 거기에 이런 식으로 string을 가지고 매칭을 해가지고 처리해 줄 수도 있구요
38:37 ~ 38:43 -  else 해가지고 이런 것도 처리가 가능하구요 굉장히 다양한 것들이
38:43 ~ 39:00 -  범위 같은 것도 쓸 수 있구요 굉장히 다양하게 사용할 수 있습니다 자 그 다음에 for loop가 우리가 맨날 사용하는 이런 것 있죠?
39:00 ~ 39:04 -  아쉬운거에요. 왜 굳이 뺄 이유가 있었을까 싶은데요.
39:00 ~ 39:20 - 전형적인 for loop는 허용하지 않음 (inti=0;i<10;i++)안됨 일반적인 (i in 0..9)로 써야함 downTo, step (i in 9..0) 안됨,for (i in 9 downTo 0){ 숫자가 정해지지 않은 (i in 0 unitl mArray.size) (i: 0 until items.length()) 컬렉션 처리 item JSONObject items[i] model String! item.getString( name: "model") (item mArray) name · "name") "image") Log.i( taq: "Gundam" model) mArray.add(Gundam(model, name, image)) 24
39:04 ~ 39:08 -  나중에 확장이 되면서 넣어줄 수도 있을지 모르겠는데요.
39:08 ~ 39:13 -  일단은 만약에 똑같은 걸 쓴다 라고 하면 이런 식으로 써 줘야 됩니다.
39:13 ~ 39:19 -  for i in 0.9 이런식으로 써 주게 되는 거죠.
39:19 ~ 39:24 -  근데 만약에 뒤에 있는 게 여기처럼 아예 숫자가 아닌 경우,
39:20 ~ 39:40 - (inti=0;i<10;i++) 안됨 (i m 0.9)로 써야함
39:24 ~ 39:30 -  0에서 until으로 작을 때까지 동작합니다.
39:30 ~ 39:37 -  이런식으로 써주는게 좋겠다는 거죠. 그 다음에 이런거 말고 컬렉션 처리 같은 것도 예를 들면 item in mArray
39:37 ~ 39:45 -  이런것도 mArray에 있는 array 아이템들 하나씩을 처리할 때 이런식으로 써줄 수 있습니다.
39:45 ~ 40:00 -  굉장히 강력합니다. 자 그 다음에 return break, 이건 그렇게 많이 쓰일 것 같진 않은데요. 레이블을 지정해서 M마크로 지정할 수 있습니다.
40:00 ~ 40:12 -  어디까지 브레이크를 할 건지 이런 것을 쓸 때 이렇게 break, nmark, loop1 이렇게 써줄 수 있는 그런 거라고 보시면 되겠구요
40:00 ~ 40:20 - return, break label @로 지정 중첩되어있을때어떤 것에 대한 것인지 명확히알려줌 안에 또 for가 있는 break를 통해 바깥의 for를 종료하고 싶을 때 사용 break와 마찬가지로 함수 안에 함수가 있을 때, 특히 식에 서 하면 밖의 함수가 되므로 지정필요 mplayer mplayer?.run stop () return@run 25
40:12 ~ 40:19 -  그 다음에 return 같은 경우에도 만약에 지금 여기 이게 함수 안인데 함수 안에 이렇게 람다식이 있다고 했을 때 그냥 return을 하게 되면
40:19 ~ 40:22 -  이 함수 자체가 return을 해 버리니까
40:20 ~ 40:40 - for가 return하면
40:22 ~ 40:25 -  지금 나는 여기서 이 run이라고 하는
40:25 ~ 40:28 -  이거를 return하겠다 라는 식으로
40:28 ~ 40:30 -  이렇게 쓸 때도 써줍니다
40:30 ~ 40:40 -  자 그 다음에 이렇게 두 개 있는 것도 프로그래머가 아닌 사람들이 보기에는 좀 이상한데요
40:40 ~ 40:41 -  코틀린에서는 세 개가 있습니다
40:40 ~ 41:00 - = 및 프로그래머가 아닌 일반인들이 잘 이해못하는 것 중에 =가 있는데 Kotlin은 3개 짜리도 있음 (2개) a "Hello" b "Hello+" 값이 같은지 비교 c:String = a b.filter != ! println(b) 의의대대 if (a == b) println("a == b") == c) (3개) println("a==c") == 객체를 가리키면 true === b) printin("a b") c) c") 의의대 HeLLo C 26
40:41 ~ 40:45 -  두 개는 뭐냐면 값이 같은지 비교하는 거고요
40:45 ~ 40:53 -  이거의 반대는 여기 하나 대신에 느낌표를 쓰니까 느낌표 하나에 equal 하나를 쓰는 거죠.
40:53 ~ 41:00 -  근데 여기 세 개 짜리는 뭐냐면요. 같은 객체를 가리키고 있는지, 레퍼런스가 같은 것을 가리키고 있는지 객체를 가려
41:00 ~ 41:07 -  그래서 만약에 이의 반대다 그러면은 맨 앞에 있는 equal이 느낌표로 대체가 되니까
41:00 ~ 41:20 - 같은지 비교 println("a== c") 같은 객체를 =의의대 Hello
41:07 ~ 41:11 -  느낌표 하나에 equal이 두 개 있는 이런 것을 쓰게 되면은
41:11 ~ 41:15 -  같은 객체를 가리키지 않을 때라고 하는 것을 얘기해 주고 있죠.
41:15 ~ 41:25 -  자 여기에 지금 보시면 a 라고 하는 건 hello, b 라고 하는 것은 hello plus니까 서로 객체가 다르죠.
41:20 ~ 41:40 - ==가 ※=
41:25 ~ 41:30 -  만약에 똑같이 hello를 썼다면 같은 객체를 가리키고 있습니다.
41:30 ~ 41:37 -  hello plus를 만들어 놓은 거죠. 그렇게 해놓고 b에서 plus가 아닌 것만 꺼내라 했으니까요.
41:37 ~ 41:45 -  lambda식으로 이렇게 굉장히 편하게 쓸 수 있죠. is라고 하는게 lambda식에서 파라미터 지정하지 않았을 때 쓰는 거라고 했으니까요.
41:40 ~ 42:00 - { ¥
41:45 ~ 41:53 -  여기 있는 이 각각 h,e,l,l,o,w 이거를 여기서 체크하는 겁니다. 그래서 w 인 경우에 not equal 인 경우에만
41:53 ~ 41:56 -  이거를 true 로 만드는 경우에만 들어가니까
41:56 ~ 42:00 -  이걸 쓰게 되면 플러스가 제외가 되겠죠.
42:00 ~ 42:05 -  그래서 여기 있는 hello plus 에서 어 이거를 돌리게 되면은
42:00 ~ 42:20 - =a 거 =의의 대
42:05 ~ 42:16 -  hello 라고 하는 것은 남구요. plus가 없어지게 되니까 값은 똑같은데 다른 객체를 가리키게 되겠죠. 그래서 b는 다른 객체 라고 했을 때
42:16 ~ 42:21 -  만약에 a 하고 b 하고 같냐 라고 했을 경우에는 같다고 나오게 되구요
42:20 ~ 42:40 - 가 있는데
42:21 ~ 42:26 -  그 다음에 a 하고 c 하고 같냐 그러면은 a 하고 c 하고는 같겠죠
42:26 ~ 42:30 -  그러니까 a 하고 c 하고 같게 나오구요 그 다음에 a 하고 b 가
42:30 ~ 42:38 -  만약에 3개짜리로 갔냐 라고 했을 경우에는 a 하고 b는 서로 다른 객체를 가리키고 있죠. 그러니까 얘는 출력이 되지 않는 겁니다.
42:38 ~ 42:47 -  그 다음에 a 하고 c는 a를 c에다 넣었으니까요. 같은 걸 참조하고 있으니까 a 하고 c가 출력되는 것을 보실 수 있겠죠.
42:47 ~ 42:53 -  자 그 다음에 let 이라든지 run 이런 것들을 여러분들이 많이 사용하시면 편할 건데요.
42:53 ~ 43:00 -  객체에 대한 코드 블록을 실행하는 겁니다. 그래서 블록 실행 결과를 리턴해주게 되는 건데요.
43:00 ~ 43:08 -  let 이라고 하는 것은 블록 내에서 앞에 있는 것을 리시버 객체 라고 하는데 이 리시버 객체를 lambda expression의
43:00 ~ 43:20 - let,run 객체에 대한 코드 실행 (mPlayer !== mPlayer!!.stop() 실행 결과 mPlayer let mPlayer?.Let MediaPlayer receiver it.stop() ^let Expression의 it으로 사용 // //return@Let run this이므로 생략 가능 mPlayer?.run this: stop() ^run 오른쪽 5개의 표현동일 //return@run mPlayer가 아니라면 mPlayer의 stop()을 호출하고 mPlayer?.stop().let mP1ayer mPlayer에 지정 mPlayer?.stop().Let 27
43:08 ~ 43:16 -  is 으로 사용을 하게 됩니다. 여기 보시면 let을 쓰면 여기 is 이라고 되어 있죠. 그래서 let 이라고 하는 것은 is 으로 되어 있는 거구요
43:16 ~ 43:22 -  run 이라고 하는 것은 블록 내에서 this 를 사용하니까 빼도 됩니다. dis 라는 것은 안 써도 되니까요.
43:20 ~ 43:40 - 블록 실행
43:22 ~ 43:24 -  예를 들면 예제를 한번 보실까요?
43:24 ~ 43:25 -  원래 이런 예제가 있는 거죠.
43:25 ~ 43:30 -  그래서 mplayer가 null이 아니라면
43:30 ~ 43:34 -  이 아니니까 느낌표 느낌표 해서 얘는 널이야 널이 아닌게 확실하다 라고 써줘도 되겠죠
43:34 ~ 43:42 -  그래서 엔플레이어의 스탑을 불러주는 겁니다 그렇게 하고 엔플레이어 엔플레이어 에다가 너를 넣어 주는 이런 문장이 있다는 거죠
43:40 ~ 44:00 - =+ull mPlayer?.let
43:42 ~ 43:52 -  이거랑 전부 다 지금 여기가 똑같은 겁니다 그래서 얘랑 똑같은 걸 쓸 때 어떻게 썼냐면요 뭔가 여기에 있는 이 결과를 엔플레이어에다 넣어라 라고 되있죠
43:52 ~ 44:00 -  여기에 엔플레이어의 물음표가 있습니다 그리고 여기에 let이 있으니까 뭐냐면요 엔플레이어가 만약에 null이다
44:00 ~ 44:05 -  라고 했을 경우에는 이거를 아무것도 실행을 하지 않는 거죠
44:00 ~ 44:20 - △
44:05 ~ 44:10 -  근데 이게 만약에 null이 아니다 라고 했을 경우엔 let a 라고 되어 있구요 안에서는 it을 사용한다고 했으니까
44:10 ~ 44:18 -  이 employer.stop 대신에 it.stop을 불러주는 거죠 그리고 여기에 꺽쇠 let이라고 하는 것은 제가 쓴 것이 아니고
44:18 ~ 44:24 -  자동으로 이렇게 넣어 주는 거죠 그래서 이 null이라고 하는 것을 반환을 해 줘 가지고
44:24 ~ 44:28 -  여기에 있는 mplay에다가 넣어주는
44:28 ~ 44:30 -  이렇게 써도 마찬가지고요
44:30 ~ 44:35 -  return 하고 이렇게 n 마크 쓰는거 말씀드렸었죠. 그래서 이렇게 쓸 수도 있구요
44:35 ~ 44:40 -  여기서는 run을 쓰는 건데요. 이 run이라고 하는 블록 내에서는 this를 사용합니다. 그러니까
44:40 ~ 44:48 -  this인 경우에는 여기 점을 이렇게 쓸 필요가 없으니까 stop을 써 가지고 나머지 똑같이 여기는 return at run이 되겠구요
44:48 ~ 44:52 -  자 이렇게 쓰실 수 있구요. 그 다음에 여기에 보면은 한 줄로 썼네요.
44:52 ~ 45:00 -  mplayer? .stop 해가지고 let 한 다음에
45:00 ~ 45:02 -  그러니까 점점 이렇게 연결해서 썼죠?
45:02 ~ 45:04 -  stop을 하고 그 다음에 let 해가지고
45:04 ~ 45:06 -  null을 넣어라 이렇게 하셔도 되겠고요
45:06 ~ 45:08 -  그 다음에 여기 보면은
45:08 ~ 45:11 -  nplayer에 stop을 하고 let을 해가지고
45:11 ~ 45:13 -  null을 return을 하니까
45:13 ~ 45:17 -  그거를 nplayer에 넣어라 이렇게 하실 수 있겠습니다
45:17 ~ 45:20 -  여러분들께서 편하신 걸로 쓰셔도 되는데요
45:20 ~ 45:22 -  글쎄 눈으로 보기에는 이게 제일 편할 것 같고요
45:20 ~ 45:40 - = full
45:22 ~ 45:25 -  좀 익숙해지시면 이런 것도 눈에 잘 들어오겠죠
45:27 ~ 45:30 -  자 그 다음에 apply with also 이런 것들이 있는데요
45:30 ~ 45:35 -  apply라고 하는 것은 여러 개 값을 지정을 할 때 나중에 우리가 써볼 코드인데요.
45:35 ~ 45:40 -  recyclerView.apply 해가지고 이런 식으로
45:40 ~ 45:48 -  recyclerView.setHashFixedSize, recyclerView.layoutManager 이렇게 각각을 다 써 줘야 되는데
45:40 ~ 46:00 - apply, with, also apply 개 지정할 때 편리 객체 recyclerView.apply RecyclerView! SetHasFixedSize(true) LayoutManager LinearLayoutManager(applicationCntext) itemAnimator DefaultItemAninator() adapter GundamAdapter() with (context 객체) context 객체가 non-null일때 also 사용하지 않을 때 사용하면 좋음 28
45:48 ~ 45:53 -  그런 것을 쓰지 않고 apply라고 하는 걸로 써주는 것이 가능하게 됩니다.
45:53 ~ 46:00 -  그 다음에 Width라고 하는 것은 Context 객체, 이 Width하고 뒤에 객체를 써주는데요.
46:00 ~ 46:03 -  none null일 때 사용하는 것입니다.
46:00 ~ 46:20 - setHasFixedSize(true)
46:03 ~ 46:07 -  그 다음에 also라고 하는 것은 코드블랙 내에서
46:07 ~ 46:10 -  리시버를 사용하지 않을 때 사용하면 좋다고 했습니다.
46:10 ~ 46:12 -  이것과 무관하게 쓸 때
46:12 ~ 46:15 -  이 리시버, 예를 들면 여기
46:15 ~ 46:18 -  recyclerView.also를 했다고 하면
46:18 ~ 46:20 -  여기서는 지금 관련된 것을 썼잖아요.
46:20 ~ 46:23 -  그런데 이 recyclerView하고 상관없는 걸 쓸 때는 이런 올 수 올 수는
46:20 ~ 46:40 - itemAR*mator
46:23 ~ 46:27 -  것이 좋겠다 라고 되어 있습니다
46:28 ~ 46:30 -  자 그 다음에 여러분들께
46:30 ~ 46:41 -  여러분들께서 프로그램을 짜시다가 만약에 웹 같은 데 보면은 구글 검색이나 이런걸 하다보면은 기존 자바 클래스로 만들어져 있는 그런 코드들이
46:40 ~ 47:00 - 코드로부터의변환 메뉴에서 Code-Convert File to 누르면 확장자가.kt로 변경되면 Kotlin 코드로 변경됨 소스 코드 변환한 후에 비교해볼수있음 코드 복사 코드 복사한 후 붙여넣기 실행하면 코드로변환되어 입력됨 인터넷에서 유용한 Android를 위한 찾으면 복사 후에 붙 여넣기로 활용 가능 29
46:41 ~ 46:49 -  많이 보실 수 있을 텐데요. 그거를 가지고 온 다음에 메뉴에서 자바 클래스를 그대로 가지고 온 다음에 메뉴에서
46:49 ~ 46:53 -  코드 컨버트 자바 파일 투 코트 트림 파lin File 이러면 기존에 만들었던
46:53 ~ 46:57 -  기탑에서 받았던 이런 자바 클래스들이 변경되는 걸 보실 수 있고요
46:57 ~ 47:00 -  그런게 아니고 그냥 웹에서 긁어다가 쓸 때
47:00 ~ 47:07 -  ctrl-c를 한 다음에 코드를 ctrl-c를 하고 ctrl-v를 붙였으면
47:00 ~ 47:20 - 확장자가.kt로변경되면 Kotlin 코드로 변환되어
47:07 ~ 47:14 -  코틀링 코드로 변환되니까요 여러분들이 어떻게 변환되는지 보시고 쓰시면 되는데요
47:14 ~ 47:20 -  잘 안될 때도 있습니다 그러니까 여러분들이 좀 주의해 가지고 쓰시면 좋을 것 같구요
47:20 ~ 47:22 -  그 다음에 프로그래밍 할 때 유용한 사이트들
47:20 ~ 47:40 - 프로그래밍할 때유용한 사이트 프로그래밍 가이드(일부한글) https://developer.ardroid.com/guide/ 가이드 https://developer.ardroid.com/kotlin/ (일부한글) https://kotlinlang.crg/docs/reference/basic-syntax.html Koans (문법 Tutorial) https://play.kotlinlaing.org/koans/overview Google 검색 StackOverflow GitHub 30
47:22 ~ 47:24 -  안드로이드 프로그래밍은 역시
47:24 ~ 47:27 -  developerandroid.com이 되겠죠.
47:27 ~ 47:30 -  그 다음에 Kotlin에 해당하는 것
47:30 ~ 47:36 -  그 다음에 KotlinRang.org 라고 하는 것도 있습니다.
47:36 ~ 47:40 -  나머지 것들도 있으니까요. 여러분들이 유용하게 사용하도록 하시고요.
47:40 ~ 47:43 -  그 다음에 이거는 프로그래밍은 아닌데
47:40 ~ 48:00 - 프로그래밍 가이드
47:43 ~ 47:47 -  프로그램 짤 때 좀 알면 좋지 않을까 싶은 것들이라서
47:47 ~ 47:49 -  여기다가 놔봤습니다.
47:49 ~ 47:54 -  프로그래밍 변수 이름 생성할 때 많이 곤란해 하셨나요?
47:54 ~ 47:57 -  그러면 이런 사이트 한번 들어가 보도록 하시고요
47:57 ~ 48:00 -  그 다음에 네이버에서 무료 강좌
48:00 ~ 48:06 -  제공하는게 있으니까 이런 것도 한번 들어가 보시구요 그 다음에 무료 이미지 라든지 음원
48:00 ~ 48:20 - 유용한 사이트 프로그래밍변수이름 생성 https://www.curioustore.com/ 네이버 무료 강좌 플랫폼 https://www.edwith.org/ 무료 이미지 음원 (그래도예의상 출처와원저작자 표기 권장) https://unsplash.com/ https://www.youtuibe.com/audiolibrary/music 이미지, 등 (일부 저작권 주의) 마우스 우클릭 -이미지 복사 https://thenounproject.com/ 붙붙넣기 (원본서식 유지) https://soundcloud.com/ https://gongu.copy1ight.or.kr/gongu/main/main.do 31
48:06 ~ 48:15 -  예의상 뭔가 가져다 썼다 라고 하면은 좀 표기를 해주는게 좋겠죠 저작권에 대해서 그래서 unsplash.com 이라든지 아니면 아니면은 음악 같은
48:15 ~ 48:22 -  경우에는 유튜브에 보면은 로그인을 하시고 오디오 라이브러리에 뮤직을 가시면
48:22 ~ 48:27 -  여기서 좋은 음악들을 받으실 수 있으니까 무료로 쓸 수 있는 거
48:27 ~ 48:30 -  그런 거 쓰시면 되겠고요.
48:30 ~ 48:37 -  이미지나 음원은 사운드 클라우드 를 사용하시면 좋을 것 같습니다.
48:37 ~ 48:43 -  자 이렇게 해서 Kotlin 언어에 대해서는 설명을 마치도록 하고요.
48:43 ~ 48:47 -  이제 다음부터 개발 환경 구축하는 것부터 그 다음에 실제로 안드로이드
48:47 ~ 48:50 -  프로그래밍 짜는 것을 설명을 드리 도록 하겠습니다.
48:50 ~ 48:53 -  이번 강의는 여기서 마치겠습니다
49:00 ~ 49:00 -  you
49:00 ~ 49:20 - 금오공대 교수 http://bwoh.tistory.com 금오공과대학교 교수학습개발센터
